# 장비 관리 모듈 상세 문서

## 목차
1. [개요](#개요)
2. [아키텍처](#아키텍처)
3. [데이터 모델](#데이터-모델)
4. [API 명세](#api-명세)
5. [코드 구조](#코드-구조)
6. [주요 기능](#주요-기능)
7. [데이터베이스 설계](#데이터베이스-설계)
8. [테스트](#테스트)
9. [이슈 및 개선사항](#이슈-및-개선사항)

---

## 개요

### 모듈 정보
- **모듈명**: Equipment Management Module
- **패키지 경로**: `biz.equipment`
- **목적**: 장비(Equipment) 정보의 등록, 조회, 수정, 삭제 및 상태 관리를 담당하는 모듈
- **기술 스택**: Spring Boot 2.7.12, MyBatis, MapStruct, Lombok

### 주요 기능
- 장비 전체/단건 조회
- 장비 등록
- 장비 정보 수정
- 장비 삭제
- 담당자 변경
- 상태 변경 (사용중/보관중/수리중/폐기)

---

## 아키텍처

### 계층 구조

```
┌─────────────────────────────────────┐
│     Controller Layer                │
│   (EquipmentController.java)        │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     Service Layer                   │
│   (EquipmentService,                │
│    EquipmentServiceImpl)            │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     DAO Layer                       │
│   (EquipmentDAO.java)               │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     Mapper Layer                    │
│   (EquipmentMapper.java,            │
│    Equipment_SQL.xml)               │
└──────────────┬──────────────────────┘
               │
┌──────────────▼──────────────────────┐
│     Database                        │
│   (PostgreSQL - EQUIPMENT 테이블)   │
└─────────────────────────────────────┘
```

### 데이터 흐름

```
Controller → Service → DAO → Mapper → Database
    ↓         ↓         ↓       ↓
  DTO      DTO/VO    VO      VO
    ↑         ↑
MapStruct  MapStruct
```

---

## 데이터 모델

### 1. EquipmentVO (Value Object)
**파일 위치**: `src/main/java/biz/equipment/vo/EquipmentVO.java`

장비 정보를 담는 도메인 모델로, Base 클래스를 상속받아 생성/수정 시간 정보를 포함합니다.

```java
public class EquipmentVO extends Base {
    private Long id;                    // 장비 ID (Primary Key)
    private String code;                // 장비 분류 코드
    private String name;                // 장비명
    private String serialNumber;        // 시리얼 번호
    private String accessNumber;        // 접근 번호
    private String director;            // 담당자
    private Status status;              // 상태 (기본값: STORAGE)
}
```

**상속 관계**:
- `Base` 클래스를 상속하여 `createdAt`, `updatedAt` 필드를 포함
- `Base` 클래스: `biz.basetime.Base`

**주요 메서드**:
- `create(EquipmentRequest)`: DTO로부터 VO 생성
- `update(EquipmentUpdate)`: DTO로부터 VO 업데이트 객체 생성

### 2. EquipmentRequest (Request DTO)
**파일 위치**: `src/main/java/biz/equipment/dto/EquipmentRequest.java`

장비 등록 시 사용되는 요청 DTO입니다.

```java
@Getter
@Builder
public class EquipmentRequest {
    Long id;                    // 장비 ID (등록 시에는 보통 null)
    private String code;        // 장비 분류 코드
    private String name;        // 장비명
    private String serialNumber;// 시리얼 번호
    private String accessNumber;// 접근 번호
    private String director;    // 담당자
    private Status status;      // 상태
}
```

**특징**:
- Lombok의 `@Builder`와 `@Getter` 어노테이션 사용
- 빌더 패턴으로 객체 생성 가능

### 3. EquipmentUpdate (Update DTO)
**파일 위치**: `src/main/java/biz/equipment/dto/EquipmentUpdate.java`

장비 수정 시 사용되는 요청 DTO입니다.

```java
@Getter
@Builder
public class EquipmentUpdate {
    private Long id;            // 장비 ID (필수)
    private String serialNumber;// 시리얼 번호
    private String accessNumber;// 접근 번호
    private String director;    // 담당자
    private Status status;      // 상태
}
```

**특징**:
- 수정 가능한 필드만 포함 (`code`, `name`은 수정 불가)
- `id` 필드는 필수 (수정 대상 식별용)

### 4. EquipmentResponse (Response DTO)
**파일 위치**: `src/main/java/biz/equipment/dto/EquipmentResponse.java`

장비 조회 시 반환되는 응답 DTO입니다.

```java
public class EquipmentResponse {
    private String code;        // 장비 분류 코드
    private String name;        // 장비명
    private String serialNumber;// 시리얼 번호
    private String accessNumber;// 접근 번호
    private String director;    // 담당자
    private Status status;      // 상태
}
```

**이슈**: 
- Lombok 어노테이션이 없어 Getter/Setter가 없음 (MapStruct가 동작하지 않을 수 있음)
- 개선 필요: `@Getter` 또는 `@Data` 어노테이션 추가 필요

### 5. Status (Enum)
**파일 위치**: `src/main/java/biz/equipment/vo/Status.java`

장비의 상태를 나타내는 열거형입니다.

```java
@Getter
public enum Status {
    USE("사용중"),           // 장비 사용 중
    STORAGE("보관중"),       // 장비 보관 중 (기본값)
    REPAIR("수리중"),        // 장비 수리 중
    DISPOSAL("폐기");        // 장비 폐기

    private final String status;  // 상태명 (한글)

    Status(String status) {
        this.status = status;
    }

    public String getStatus(){
        return status;
    }
}
```

---

## API 명세

### 1. 장비 목록 조회

**엔드포인트**: `GET /equipment/equipmentList.do`

**설명**: 등록된 모든 장비 목록을 조회합니다.

**요청 파라미터**: 없음

**응답**: Thymeleaf 템플릿 렌더링
- Model 속성: `equipment` (List<EquipmentResponse>)
- View: `equipment/equipmentList`

**컨트롤러 코드**:
```java
@GetMapping("/equipment/equipmentList.do")
public String getEquipmentCodes(Model model) {
    model.addAttribute("equipment", equipmentService.getEquipments());
    return "equipment/equipmentList";
}
```

---

### 2. 장비 단건 조회

**엔드포인트**: `GET /view.do`

**설명**: 특정 장비의 상세 정보를 조회합니다.

**요청 파라미터**:
- `id` (Long, required): 장비 ID

**응답**: Thymeleaf 템플릿 렌더링
- Model 속성: `equipmentResponse` (EquipmentResponse)
- View: `equipment/view`

**컨트롤러 코드**:
```java
@GetMapping("view.do")
public String getEquipmentCode(@RequestParam("id") Long id, Model model) {
    model.addAttribute(equipmentService.getEquipment(id));
    return "equipment/view";
}
```

**이슈**: 
- RequestMapping 경로가 불완전함 (`/equipment/view.do`가 되어야 할 것 같음)
- Model에 추가할 때 키 이름이 지정되지 않음

---

### 3. 장비 등록 폼

**엔드포인트**: `GET /insert.do`

**설명**: 장비 등록 폼을 표시합니다.

**요청 파라미터**: 없음

**응답**: Thymeleaf 템플릿 렌더링
- View: `equipment/insert`

**컨트롤러 코드**:
```java
@GetMapping("/insert.do")
public String insertForm(){
    return "equipment/insert";
}
```

---

### 4. 장비 등록

**엔드포인트**: `POST /insert.do`

**설명**: 새 장비를 등록합니다.

**요청 바디**: `EquipmentRequest` (Form Data)
- `code` (String): 장비 분류 코드
- `name` (String): 장비명
- `serialNumber` (String): 시리얼 번호
- `accessNumber` (String): 접근 번호
- `director` (String): 담당자
- `status` (Status): 상태

**응답**: 리다이렉트
- URL: `/equipment/list.do`

**컨트롤러 코드**:
```java
@PostMapping("/insert.do")
public String insertEquipment(@ModelAttribute EquipmentRequest equipmentRequest) {
    equipmentService.insertEquipment(equipmentRequest);
    return "redirect:/equipment/list.do";
}
```

**이슈**:
- 리다이렉트 URL이 `/equipment/list.do`인데, 실제 목록 조회 URL은 `/equipment/equipmentList.do`임
- URL 불일치 문제 존재

---

### 5. 장비 수정 폼

**엔드포인트**: `GET /update.do`

**설명**: 장비 수정 폼을 표시합니다.

**요청 파라미터**:
- `id` (Long, required): 장비 ID

**응답**: Thymeleaf 템플릿 렌더링
- Model 속성: `equipmentResponse` (EquipmentResponse)
- View: `equipment/update`

**컨트롤러 코드**:
```java
@GetMapping("/update.do")
public String updateForm(@RequestParam("id") Long id, Model model) {
    model.addAttribute(equipmentService.getEquipment(id));
    return "equipment/update";
}
```

---

### 6. 장비 수정

**엔드포인트**: `POST /update.do`

**설명**: 장비 정보를 수정합니다.

**요청 바디**: `EquipmentUpdate` (Form Data)
- `id` (Long, required): 장비 ID
- `serialNumber` (String): 시리얼 번호
- `accessNumber` (String): 접근 번호
- `director` (String): 담당자
- `status` (Status): 상태

**응답**: 리다이렉트
- URL: `/equipment/list.do`

**컨트롤러 코드**:
```java
@PostMapping("/update.do")
public String updateEquipment(@ModelAttribute EquipmentUpdate equipmentUpdate) {
    equipmentService.updateEquipment(equipmentUpdate);
    return "redirect:/equipment/list.do";
}
```

**참고**: `code`와 `name`은 수정 불가 (EquipmentUpdate에 포함되지 않음)

---

### 7. 장비 삭제

**엔드포인트**: `DELETE /delete.do`

**설명**: 장비를 삭제합니다.

**요청 파라미터**:
- `id` (Long, required): 장비 ID

**응답**: 리다이렉트
- URL: `/equipment/list.do`

**컨트롤러 코드**:
```java
@DeleteMapping("/delete.do")
public String deleteEquipment(Long id) {
    equipmentService.deleteEquipment(id);
    return "redirect:/equipment/list.do";
}
```

**주의**: HTML 폼에서는 DELETE 메서드를 지원하지 않으므로, 실제로는 POST 메서드와 hidden input을 사용해야 할 수 있습니다.

---

### 8. 담당자 변경 폼

**엔드포인트**: `GET /director/update.do`

**설명**: 담당자 변경 폼을 표시합니다.

**요청 파라미터**:
- `id` (Long, required): 장비 ID

**응답**: Thymeleaf 템플릿 렌더링
- Model 속성: `equipmentResponse` (EquipmentResponse)
- View: `equipment/director/update`

**컨트롤러 코드**:
```java
@GetMapping("/director/update.do")
public String updateDirectorForm(@RequestParam("id") Long id, Model model) {
    model.addAttribute(equipmentService.getEquipment(id));
    return "equipment/director/update";
}
```

---

### 9. 담당자 변경

**엔드포인트**: `POST /director/update.do`

**설명**: 장비의 담당자를 변경합니다.

**요청 파라미터**:
- `id` (Long, required): 장비 ID
- `director` (String, required): 새로운 담당자명

**응답**: 리다이렉트
- URL: `/equipment/list.do`

**컨트롤러 코드**:
```java
@PostMapping("/director/update.do")
public String updateDirector(@RequestParam("id") Long id, @RequestParam("director") String director) {
    equipmentService.updateDirector(id, director);
    return "redirect:/equipment/list.do";
}
```

---

### 10. 상태 변경

**엔드포인트**: `POST /status/update.do`

**설명**: 장비의 상태를 변경합니다.

**요청 파라미터**:
- `id` (Long, required): 장비 ID
- `status` (Status, required): 새로운 상태 (USE/STORAGE/REPAIR/DISPOSAL)

**응답**: 리다이렉트
- URL: `/equipment/status/list.do`

**컨트롤러 코드**:
```java
@PostMapping("/status/update.do")
public String updateStatusEquipment(@RequestParam("id")Long id, @RequestParam("status") Status status) {
    equipmentService.updateStatus(id, status);
    return "redirect:/equipment/status/list.do";
}
```

**참고**: 리다이렉트 URL이 `/equipment/status/list.do`인데, 해당 경로의 컨트롤러가 존재하는지 확인 필요

---

## 코드 구조

### 1. Controller Layer

**파일**: `src/main/java/biz/equipment/controller/EquipmentController.java`

**책임**:
- HTTP 요청/응답 처리
- 요청 파라미터 바인딩
- 서비스 계층 호출
- 뷰 렌더링 또는 리다이렉트

**의존성**:
- `EquipmentService`: 비즈니스 로직 처리를 위한 서비스

**주요 메서드**:
- `getEquipmentCodes()`: 장비 목록 조회
- `getEquipmentCode()`: 장비 단건 조회
- `insertForm()`: 등록 폼 표시
- `insertEquipment()`: 장비 등록
- `updateForm()`: 수정 폼 표시
- `updateEquipment()`: 장비 수정
- `deleteEquipment()`: 장비 삭제
- `updateDirectorForm()`: 담당자 변경 폼
- `updateDirector()`: 담당자 변경
- `updateStatusEquipment()`: 상태 변경

---

### 2. Service Layer

#### 2.1 Service Interface
**파일**: `src/main/java/biz/equipment/service/EquipmentService.java`

**책임**: 비즈니스 로직 인터페이스 정의

**주요 메서드**:
```java
public interface EquipmentService {
    List<EquipmentResponse> getEquipments();      // 장비 전체 조회
    EquipmentResponse getEquipment(Long id);      // 장비 단건 조회
    void insertEquipment(EquipmentRequest request); // 장비 등록
    void updateEquipment(EquipmentUpdate request);  // 장비 수정
    void deleteEquipment(Long id);                // 장비 삭제
    void updateDirector(Long id, String director); // 담당자 변경
    void updateStatus(Long id, Status status);    // 상태 변경
}
```

#### 2.2 Service Implementation
**파일**: `src/main/java/biz/equipment/service/EquipmentServiceImpl.java`

**책임**: 비즈니스 로직 구현

**의존성**:
- `EquipmentDAO`: 데이터 접근 객체

**주요 로직**:

1. **장비 조회**:
   - DAO를 통해 VO 리스트 조회
   - MapStruct를 사용하여 VO → DTO 변환

2. **장비 등록**:
   - Request DTO로부터 VO 생성
   - DAO를 통해 저장

3. **장비 수정**:
   - Update DTO로부터 VO 생성
   - DAO를 통해 업데이트

4. **장비 삭제**:
   - ID를 통해 삭제

5. **담당자/상태 변경**:
   - DAO의 특정 업데이트 메서드 호출

**코드 예시**:
```java
@Service
@RequiredArgsConstructor
public class EquipmentServiceImpl implements EquipmentService {

    final EquipmentDAO equipmentDAO;

    @Override
    public List<EquipmentResponse> getEquipments() {
        return EquipmentMapStruct.INSTANCE.toDto(equipmentDAO.findAll());
    }

    @Override
    public void insertEquipment(EquipmentRequest request) {
        equipmentDAO.save(new EquipmentVO().create(request));
    }

    @Override
    public void updateEquipment(EquipmentUpdate request) {
        equipmentDAO.update(new EquipmentVO().update(request));
    }
}
```

**이슈**:
- 38번째 줄: `update` 메서드 호출 시 공백이 있음 (`update` → `update`)
- 예외 처리 로직이 없음
- 입력 값 검증 로직이 없음

---

### 3. DAO Layer

**파일**: `src/main/java/biz/equipment/dao/EquipmentDAO.java`

**책임**: 데이터 접근 로직 처리

**상속 관계**: `EgovComAbstractDAO` 상속

**의존성**:
- `EquipmentMapper`: MyBatis Mapper 인터페이스

**주요 메서드**:
```java
public class EquipmentDAO extends EgovComAbstractDAO {
    List<EquipmentVO> findAll();                    // 전체 조회
    EquipmentVO findById(Long id);                  // 단건 조회
    int save(EquipmentVO equipmentVO);              // 저장
    void update(EquipmentVO equipmentVO);           // 수정
    void deleteById(Long id);                       // 삭제
    void deleteAll();                               // 전체 삭제
    void updateDirector(Long id, String director);  // 담당자 변경
    void updateStatus(Long id, Status status);      // 상태 변경
}
```

---

### 4. Mapper Layer

#### 4.1 Mapper Interface
**파일**: `src/main/java/biz/mapper/EquipmentMapper.java`

**책임**: MyBatis Mapper 인터페이스 정의

**주요 메서드**:
```java
@Mapper
public interface EquipmentMapper {
    List<EquipmentVO> findAll();
    EquipmentVO findById(@Param("id") Long id);
    int save(@Param("equipment") EquipmentVO equipmentVO);
    void update(@Param("equipment") EquipmentVO equipmentVO);
    void deleteById(@Param("id") Long id);
    void deleteAll();
    void updateDirector(@Param("id") Long id, @Param("director") String director);
    void updateStatus(@Param("id") Long id, @Param("status") Status status);
}
```

#### 4.2 Mapper XML
**파일**: `src/main/resources/egovframework/mapper/biz/equipment/Equipment_SQL.xml`

**책임**: SQL 쿼리 정의

**주요 SQL**:

1. **전체 조회**:
```xml
<select id="findAll" resultType="biz.equipment.vo.EquipmentVO">
    SELECT ID, CODE, NAME, SERIAL_NUMBER, ACCESS_NUMBER, DIRECTOR, STATUS
    FROM EQUIPMENT
</select>
```

2. **단건 조회**:
```xml
<select id="findById" resultType="biz.equipment.vo.EquipmentVO">
    SELECT ID, CODE, NAME, SERIAL_NUMBER, ACCESS_NUMBER, DIRECTOR, STATUS
    FROM EQUIPMENT
    WHERE ID = #{id}
</select>
```

3. **등록**:
```xml
<insert id="save" useGeneratedKeys="true" keyProperty="id">
    INSERT INTO EQUIPMENT(CODE, NAME, SERIAL_NUMBER, ACCESS_NUMBER, DIRECTOR, STATUS)
    VALUES (#{equipment.code}, #{equipment.name}, #{equipment.serialNumber}, 
            #{equipment.accessNumber}, #{equipment.director}, #{equipment.status})
</insert>
```

4. **수정**:
```xml
<update id="update" parameterType="biz.equipment.vo.EquipmentVO">
    UPDATE EQUIPMENT
    SET SERIAL_NUMBER = #{equipment.serialNumber},
        ACCESS_NUMBER = #{equipment.accessNumber},
        DIRECTOR = #{equipment.director},
        STATUS = #{equipment.status}
    WHERE ID = #{equipment.id, jdbcType=BIGINT}
</update>
```

5. **삭제**:
```xml
<delete id="deleteById" parameterType="long">
    DELETE FROM EQUIPMENT
    WHERE ID = #{id,jdbcType=BIGINT}
</delete>
```

6. **담당자 변경**:
```xml
<update id="updateDirector">
    UPDATE EQUIPMENT
    SET DIRECTOR = #{director}
    WHERE ID = #{id, jdbcType=BIGINT}
</update>
```

7. **상태 변경**:
```xml
<update id="updateStatus">
    UPDATE EQUIPMENT
    SET STATUS = #{status}
    WHERE ID = #{id, jdbcType=BIGINT}
</update>
```

**특징**:
- `useGeneratedKeys="true"`로 자동 생성되는 ID를 받아옴
- `jdbcType=BIGINT``로 타입 명시

---

### 5. MapStruct

**파일**: `src/main/java/biz/equipment/mapstruct/EquipmentMapStruct.java`

**책임**: VO와 DTO 간 변환 처리

**설정**:
```java
@Mapper(componentModel = "spring")
public interface EquipmentMapStruct {
    EquipmentMapStruct INSTANCE = Mappers.getMapper(EquipmentMapStruct.class);

    EquipmentResponse toDto(EquipmentVO vo);
    List<EquipmentResponse> toDto(List<EquipmentVO> equipmentCodeVO);
}
```

**특징**:
- 컴파일 타임에 구현 클래스 자동 생성
- `componentModel = "spring"`으로 Spring Bean으로 등록

**이슈**:
- `EquipmentResponse`에 Getter가 없으면 MapStruct가 동작하지 않을 수 있음
- 개선 필요: `EquipmentResponse`에 Lombok `@Getter` 추가

---

## 주요 기능

### 1. 장비 조회

**전체 조회 흐름**:
```
사용자 요청 → Controller → Service → DAO → Mapper → Database
                                    ↓
                              VO 리스트 반환
                                    ↓
                              MapStruct 변환
                                    ↓
                              DTO 리스트 반환
                                    ↓
                              Model에 추가 → View 렌더링
```

**단건 조회 흐름**:
```
사용자 요청 (ID 포함) → Controller → Service → DAO → Mapper → Database
                                                      ↓
                                                VO 반환
                                                      ↓
                                                MapStruct 변환
                                                      ↓
                                                DTO 반환
                                                      ↓
                                                Model에 추가 → View 렌더링
```

---

### 2. 장비 등록

**등록 흐름**:
```
사용자 요청 (Form Data) → Controller → Service
                                         ↓
                                   Request DTO → VO 생성
                                         ↓
                                   DAO 저장
                                         ↓
                                   Database INSERT
                                         ↓
                                   리다이렉트
```

**주의사항**:
- `code`와 `name`은 장비 분류 코드와 연결됨 (EquipmentCode 테이블 참조)
- `status` 기본값은 `STORAGE` (보관중)
- ID는 자동 생성 (AUTO_INCREMENT)

---

### 3. 장비 수정

**수정 흐름**:
```
사용자 요청 (Form Data + ID) → Controller → Service
                                           ↓
                                     Update DTO → VO 생성
                                           ↓
                                     DAO 업데이트
                                           ↓
                                     Database UPDATE
                                           ↓
                                     리다이렉트
```

**수정 가능 필드**:
- `serialNumber` (시리얼 번호)
- `accessNumber` (접근 번호)
- `director` (담당자)
- `status` (상태)

**수정 불가 필드**:
- `id` (기본키)
- `code` (장비 분류 코드)
- `name` (장비명)

---

### 4. 장비 삭제

**삭제 흐름**:
```
사용자 요청 (ID) → Controller → Service → DAO → Mapper → Database
                                                          ↓
                                                    DELETE 실행
                                                          ↓
                                                    리다이렉트
```

**주의사항**:
- 물리적 삭제 (SOFT DELETE 아님)
- 관련 데이터 존재 시 외래키 제약조건 위반 가능성
- 삭제 전 검증 로직 없음

---

### 5. 담당자 변경

**변경 흐름**:
```
사용자 요청 (ID + director) → Controller → Service → DAO → Mapper → Database
                                                                      ↓
                                                                UPDATE DIRECTOR
                                                                      ↓
                                                                리다이렉트
```

**특징**:
- 담당자만 변경하는 전용 API
- 전체 수정과 별도로 분리된 기능

---

### 6. 상태 변경

**변경 흐름**:
```
사용자 요청 (ID + status) → Controller → Service → DAO → Mapper → Database
                                                                   ↓
                                                             UPDATE STATUS
                                                                   ↓
                                                             리다이렉트
```

**상태 종류**:
- `USE`: 사용중
- `STORAGE`: 보관중 (기본값)
- `REPAIR`: 수리중
- `DISPOSAL`: 폐기

**특징**:
- 상태만 변경하는 전용 API
- 전체 수정과 별도로 분리된 기능

---

## 데이터베이스 설계

### EQUIPMENT 테이블

**테이블명**: `EQUIPMENT`

**컬럼 구조**:

| 컬럼명 | 타입 | 제약조건 | 설명 |
|--------|------|----------|------|
| ID | BIGINT | PRIMARY KEY, AUTO_INCREMENT | 장비 ID |
| CODE | VARCHAR | NOT NULL | 장비 분류 코드 (EQUIPMENT_CODE 테이블 참조) |
| NAME | VARCHAR | NOT NULL | 장비명 |
| SERIAL_NUMBER | VARCHAR | | 시리얼 번호 |
| ACCESS_NUMBER | VARCHAR | | 접근 번호 |
| DIRECTOR | VARCHAR | | 담당자 |
| STATUS | VARCHAR | | 상태 (USE/STORAGE/REPAIR/DISPOSAL) |
| CREATED_AT | TIMESTAMP | | 생성일시 (Base 클래스) |
| UPDATED_AT | TIMESTAMP | | 수정일시 (Base 클래스) |

**인덱스**: (추정)
- PRIMARY KEY: `ID`
- 외래키: `CODE` → `EQUIPMENT_CODE.CODE` (추정)

**관계**:
- `EQUIPMENT.CODE` → `EQUIPMENT_CODE.CODE` (Many-to-One)

**참고**: 
- 실제 테이블에 `CREATED_AT`, `UPDATED_AT` 컬럼이 있는지는 SQL XML에 포함되지 않음
- Base 클래스에는 해당 필드가 있으나, 실제 매핑은 확인 필요

---

## 테스트

### 테스트 파일
**위치**: `src/test/java/biz/equipment/service/EquipmentServiceTest.java`

**테스트 환경**:
- Spring Boot Test 사용
- `TestMapperConfig` 임포트
- `@SpringBootTest`로 통합 테스트

**테스트 케이스**:

1. **장비 전체 조회 테스트**:
   - `장비_전체_조회를_성공한다()`
   - 검증: 조회된 장비 수가 2개인지 확인

2. **장비 등록 테스트**:
   - `장비_등록을_성공한다()`
   - 검증: 등록 후 장비 수가 3개가 되는지 확인

3. **장비 수정 테스트**:
   - `장비_수정을_성공한다()`
   - 검증: 수정된 시리얼 번호가 올바른지 확인

4. **장비 삭제 테스트**:
   - `장비_삭제를_성공한다()`
   - 검증: 삭제 후 장비 수가 1개가 되는지 확인

5. **담당자 변경 테스트**:
   - `관리자_수정을_성공한다()`
   - 검증: 변경된 담당자명이 올바른지 확인

6. **상태 변경 테스트**:
   - `장비_상태_변경을_성공한다()`
   - 검증: 변경된 상태가 올바른지 확인

**테스트 데이터**:
- `@BeforeEach`에서 테스트 데이터 초기화
- 각 테스트 전 `deleteAll()` 실행하여 초기 상태 유지

**헬퍼 메서드**:
- `createEquipmentVO()`: VO 생성
- `createRequest()`: Request DTO 생성
- `createUpdate()`: Update DTO 생성

---

## 이슈 및 개선사항

### 1. Critical Issues

#### 1.1 URL 경로 불일치
**문제**:
- 컨트롤러에서 리다이렉트 시 `/equipment/list.do` 사용
- 실제 목록 조회 URL은 `/equipment/equipmentList.do`
- 이로 인해 리다이렉트 실패 가능

**영향**:
- 장비 등록/수정/삭제 후 목록 페이지로 이동하지 않음
- 사용자 경험 저하

**해결 방안**:
- 리다이렉트 URL을 `/equipment/equipmentList.do`로 통일
- 또는 목록 조회 URL을 `/equipment/list.do`로 변경

**수정 위치**:
- `EquipmentController.java` (여러 메서드)

---

#### 1.2 EquipmentResponse Getter/Setter 없음
**문제**:
- `EquipmentResponse` 클래스에 Lombok 어노테이션 없음
- MapStruct가 Getter를 사용하지 못할 수 있음

**영향**:
- VO → DTO 변환 실패 가능
- 조회 기능이 동작하지 않을 수 있음

**해결 방안**:
```java
@Getter
@Setter
public class EquipmentResponse {
    // ... 필드들
}
```

**수정 위치**:
- `src/main/java/biz/equipment/dto/EquipmentResponse.java`

---

#### 1.3 EquipmentServiceImpl 코드 오타
**문제**:
- 38번째 줄: `new EquipmentVO(). update(request)` (공백 있음)
- 실제로는 `new EquipmentVO().update(request)`가 되어야 함

**영향**:
- 컴파일 에러 발생
- 수정 기능이 동작하지 않음

**해결 방안**:
- 공백 제거

**수정 위치**:
- `src/main/java/biz/equipment/service/EquipmentServiceImpl.java:38`

---

### 2. Medium Issues

#### 2.1 예외 처리 없음
**문제**:
- Service 계층에 예외 처리 로직 없음
- 데이터베이스 에러 시 사용자에게 명확한 메시지 전달 불가

**해결 방안**:
- `try-catch` 블록 추가
- 커스텀 예외 클래스 생성
- `@ControllerAdvice`를 통한 전역 예외 처리

---

#### 2.2 입력 값 검증 없음
**문제**:
- 요청 DTO에 유효성 검증 어노테이션 없음
- 잘못된 데이터가 데이터베이스에 저장될 수 있음

**해결 방안**:
```java
public class EquipmentRequest {
    @NotBlank(message = "장비 분류 코드는 필수입니다.")
    private String code;
    
    @NotBlank(message = "장비명은 필수입니다.")
    private String name;
    
    // ... 기타 필드
}
```

**필요한 의존성**:
- `spring-boot-starter-validation`
- `@Valid` 어노테이션 사용

---

#### 2.3 Model 속성 키 이름 미지정
**문제**:
- `model.addAttribute(equipmentService.getEquipment(id))` 형태로 사용
- 키 이름이 클래스명(소문자)로 자동 생성됨
- 일관성 없는 키 이름 사용

**해결 방안**:
```java
model.addAttribute("equipment", equipmentService.getEquipment(id));
```

---

#### 2.4 DELETE 메서드 사용 문제
**문제**:
- HTML 폼에서는 DELETE 메서드를 직접 지원하지 않음
- 실제로는 POST 메서드와 hidden input 사용해야 함

**해결 방안**:
- `@DeleteMapping` 대신 `@PostMapping` 사용
- 또는 JavaScript로 AJAX 요청

---

### 3. Low Priority Issues

#### 3.1 상태별 조회 기능 없음
**문제**:
- 상태별로 장비를 조회하는 기능 없음
- 상태 변경 후 `/equipment/status/list.do`로 리다이렉트하지만 해당 컨트롤러 없음

**해결 방안**:
- 상태별 조회 API 추가
- 상태 변경 후 목록 페이지로 리다이렉트 경로 수정

---

#### 3.2 페이징 처리 없음
**문제**:
- 전체 조회 시 페이징 처리 없음
- 데이터가 많아질 경우 성능 문제 발생 가능

**해결 방안**:
- 페이징 처리 추가 (Pageable 사용)
- 검색 기능 추가

---

#### 3.3 로깅 부족
**문제**:
- 중요 작업에 대한 로깅이 없음
- 디버깅 및 추적이 어려움

**해결 방안**:
- Service 계층에 로깅 추가
- 예외 발생 시 로깅

---

#### 3.4 Soft Delete 미지원
**문제**:
- 삭제 시 물리적 삭제만 수행
- 삭제 이력 추적 불가

**해결 방안**:
- `deleted_at` 컬럼 추가
- Soft Delete 구현

---

## 개선 권장사항

### 1. 즉시 수정 필요
1. URL 경로 불일치 해결
2. `EquipmentResponse`에 Lombok 추가
3. `EquipmentServiceImpl` 코드 오타 수정

### 2. 단기 개선
1. 예외 처리 추가
2. 입력 값 검증 추가
3. Model 속성 키 이름 명시

### 3. 중장기 개선
1. 페이징 및 검색 기능 추가
2. Soft Delete 구현
3. 로깅 강화
4. API 문서화 (Swagger)

---

## 결론

장비 관리 모듈은 기본적인 CRUD 기능을 제공하는 잘 구조화된 모듈입니다. 하지만 URL 경로 불일치, Getter/Setter 누락 등 몇 가지 중요한 이슈가 있어 즉시 수정이 필요합니다. 또한 예외 처리, 입력 값 검증 등 보완 사항이 있습니다.

전반적으로 계층 분리가 잘 되어 있고, MapStruct를 사용한 DTO 변환, 테스트 코드 작성 등 좋은 설계 패턴을 따르고 있습니다.

---

**문서 작성일**: 2024년 12월
**작성자**: AI Assistant
**버전**: 1.0

